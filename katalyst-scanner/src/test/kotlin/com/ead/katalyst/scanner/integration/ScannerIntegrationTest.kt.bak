package com.ead.katalyst.scanner.integration

import com.ead.katalyst.scanner.core.DiscoveryConfig
import com.ead.katalyst.scanner.core.DiscoveryRegistry
import com.ead.katalyst.scanner.core.DiscoveryPredicate
import com.ead.katalyst.scanner.fixtures.*
import com.ead.katalyst.repositories.*
import com.ead.katalyst.common.*
import com.ead.katalyst.services.*
import com.ead.katalyst.validators.*
import com.ead.katalyst.events.*
import com.ead.katalyst.handlers.*
import com.ead.katalyst.scanner.predicates.*
import com.ead.katalyst.scanner.scanner.InMemoryDiscoveryRegistry
import com.ead.katalyst.scanner.scanner.KotlinMethodScanner
import com.ead.katalyst.scanner.scanner.ReflectionsTypeScanner
import com.ead.katalyst.scanner.util.GenericTypeExtractor
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue
import kotlin.test.assertNotNull

/**
 * Integration tests for the complete scanner framework.
 *
 * Tests the interaction between:
 * - ReflectionsTypeScanner
 * - KotlinMethodScanner
 * - DiscoveryRegistry
 * - GenericTypeExtractor
 * - Predicates
 * - DiscoveryMetadata
 */
class ScannerIntegrationTest {

    // ========== Repository Discovery Integration ==========

    @Test
    fun `should discover and extract type parameters from repositories`() {
        // 1. Discover repository classes
        val scanner = ReflectionsTypeScanner<Repository<*, *>>(
            Class.forName("com.ead.katalyst.repositories.Repository") as Class<Repository<*, *>>,
            listOf("com.ead.katalyst.repositories"),
            predicate = isConcrete()
        )

        val discovered = scanner.discover()

        // 2. Extract type parameters from each
        val repositoryInfo = discovered.mapNotNull { clazz ->
            val types = GenericTypeExtractor.extractTypeArguments(clazz, Class.forName("com.ead.katalyst.repositories.Repository"))
            if (types.size == 2) {
                clazz to (types[0] to types[1])
            } else null
        }

        assertTrue(repositoryInfo.isNotEmpty())

        // Verify we got the expected types
        val userRepoEntry = repositoryInfo.find { it.first == UserRepository::class.java }
        assertNotNull(userRepoEntry)
        assertEquals(User::class.java, userRepoEntry.second.first)
        assertEquals(UserDTO::class.java, userRepoEntry.second.second)
    }

    @Test
    fun `should register discovered repositories in registry`() {
        // 1. Discover
        val scanner = ReflectionsTypeScanner<Repository<*, *>>(
            Repository::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = isConcrete()
        )

        val discovered = scanner.discover()

        // 2. Register
        val registry: DiscoveryRegistry<Repository<*, *>> =
            InMemoryDiscoveryRegistry(Repository::class.java)
        discovered.forEach { registry.register(it) }

        // 3. Verify registration
        assertEquals(discovered.size, registry.size())
        assertTrue(registry.isRegistered(UserRepository::class.java))
        assertTrue(registry.isRegistered(ProductRepository::class.java))
    }

    @Test
    fun `should query repositories by name`() {
        val scanner = ReflectionsTypeScanner<Repository<*, *>>(
            Repository::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = isConcrete()
        )

        val discovered = scanner.discover()

        val registry: DiscoveryRegistry<Repository<*, *>> =
            InMemoryDiscoveryRegistry(Repository::class.java)
        discovered.forEach { registry.register(it) }

        val userRepository = registry.getByName("UserRepository")
        assertNotNull(userRepository)
        assertEquals(UserRepository::class.java, userRepository)
    }

    // ========== Service Discovery with Methods ==========

    @Test
    fun `should discover services and their annotated methods`() {
        // 1. Discover services
        val scanner = ReflectionsTypeScanner<TestService>(
            TestService::class.java,
            listOf("com.ead.katalyst.scanner.fixtures")
        )

        val services = scanner.discover()

        // 2. Discover methods in each service
        val methodScanner = KotlinMethodScanner<TestService>()
        val methodsByService = methodScanner.discoverMethodsGroupedByClass(services)

        assertTrue(methodsByService.isNotEmpty())

        // 3. Verify we got methods
        val serviceWithMethods = methodsByService.values.filter { it.isNotEmpty() }
        assertTrue(serviceWithMethods.isNotEmpty())
    }

    @Test
    fun `should discover and filter annotated methods`() {
        val scanner = ReflectionsTypeScanner<TestService>(
            TestService::class.java,
            listOf("com.ead.katalyst.scanner.fixtures")
        )

        val services = scanner.discover()

        val methodScanner = KotlinMethodScanner<TestService>()
        val allMethods = methodScanner.discoverMethods(services)

        // Filter to only TestAnnotation
        val annotatedMethods = methodScanner.discoverMethods(services) { metadata ->
            metadata.findAnnotation<TestAnnotation>() != null
        }

        assertTrue(annotatedMethods.isNotEmpty())
    }

    @Test
    fun `should discover validators and their validation methods`() {
        val scanner = ReflectionsTypeScanner<Validator<*>>(
            Validator::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = isConcrete()
        )

        val validators = scanner.discover()

        assertTrue(validators.isNotEmpty())

        val methodScanner = KotlinMethodScanner<Validator<*>>()
        val methods = methodScanner.discoverMethods(validators)

        // Should find validate methods
        val validateMethods = methods.filter { metadata ->
            metadata.name == "validate"
        }

        assertTrue(validateMethods.isNotEmpty())
    }

    @Test
    fun `should discover event handlers with type extraction`() {
        val scanner = ReflectionsTypeScanner<EventHandler<*>>(
            EventHandler::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = isConcrete()
        )

        val handlers = scanner.discover()

        // Extract event types
        val handlerEventTypes = handlers.mapNotNull { clazz ->
            val eventType = GenericTypeExtractor.extractTypeArgument(
                clazz,
                EventHandler::class.java,
                0
            )
            clazz to eventType
        }

        assertTrue(handlerEventTypes.isNotEmpty())

        // Verify we got UserCreatedEvent
        val userCreatedHandler = handlerEventTypes.find {
            it.second == UserCreatedEvent::class.java
        }
        assertNotNull(userCreatedHandler)
    }

    // ========== Complex Filtering Scenarios ==========

    @Test
    fun `should filter services by methods and predicates`() {
        val predicate = isConcrete<TestService>()
            .and(isNotInterface<TestService>())
            .and(hasPublicMethods<TestService>())

        val scanner = ReflectionsTypeScanner(
            TestService::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = predicate
        )

        val discovered = scanner.discover()

        assertTrue(discovered.isNotEmpty())
    }

    @Test
    fun `should discover and organize services by package`() {
        val scanner = ReflectionsTypeScanner<TestService>(
            TestService::class.java,
            listOf("com.ead.katalyst.scanner.fixtures")
        )

        val discovered = scanner.discover()

        // Group by package
        val byPackage = discovered.groupBy { it.packageName }

        assertTrue(byPackage.isNotEmpty())
        assertTrue(byPackage.all { it.key.startsWith("com.ead.katalyst") })
    }

    @Test
    fun `should discover and track metadata with methods and types`() {
        val scanner = ReflectionsTypeScanner<Repository<*, *>>(
            Repository::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = isConcrete()
        )

        val enhanced = scanner.discoverWithEnhancedMetadata(
            baseType = Repository::class.java,
            scanMethods = true
        )

        assertTrue(enhanced.isNotEmpty())

        enhanced.forEach { (clazz, metadata) ->
            // Verify type parameters are extracted
            val typeParams = metadata.getTypeParameters()
            assertEquals(2, typeParams.size)

            // Verify class info is present
            assertEquals(clazz.simpleName, metadata.simpleName)
        }
    }

    // ========== End-to-End Workflow Tests ==========

    @Test
    fun `complete workflow - discover validators and their validate methods`() {
        // 1. Discover validator classes
        val classScanner = ReflectionsTypeScanner<Validator<*>>(
            Validator::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = isConcrete()
        )

        val validators = classScanner.discover()
        assertTrue(validators.isNotEmpty())

        // 2. Register them
        val registry: DiscoveryRegistry<Validator<*>> =
            InMemoryDiscoveryRegistry(Validator::class.java)
        validators.forEach { registry.register(it) }

        assertEquals(validators.size, registry.size())

        // 3. Discover their methods
        val methodScanner = KotlinMethodScanner<Validator<*>>()
        val methods = methodScanner.discoverMethods(validators)

        // 4. Verify validate method exists
        val validateMethods = methods.filter { metadata ->
            metadata.name == "validate"
        }

        assertTrue(validateMethods.isNotEmpty())
    }

    @Test
    fun `complete workflow - discover event handlers with type mapping`() {
        // 1. Discover handlers
        val classScanner = ReflectionsTypeScanner<EventHandler<*>>(
            EventHandler::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = isConcrete()
        )

        val handlers = classScanner.discover()
        assertTrue(handlers.isNotEmpty())

        // 2. Extract event types
        val eventMapping = handlers.associateWith { clazz ->
            GenericTypeExtractor.extractTypeArgument(
                clazz,
                EventHandler::class.java,
                0
            )
        }

        // 3. Verify mappings
        assertTrue(eventMapping.values.any { it == UserCreatedEvent::class.java })
        assertTrue(eventMapping.values.any { it == OrderPlacedEvent::class.java })

        // 4. Register handlers
        val registry: DiscoveryRegistry<EventHandler<*>> =
            InMemoryDiscoveryRegistry(EventHandler::class.java)
        handlers.forEach { registry.register(it) }

        assertEquals(handlers.size, registry.size())
    }

    @Test
    fun `complete workflow - discover repositories with full metadata`() {
        // 1. Discover repository implementations
        val scanner = ReflectionsTypeScanner<Repository<*, *>>(
            Repository::class.java,
            listOf("com.ead.katalyst.scanner.fixtures"),
            predicate = isConcrete()
        )

        val discovered = scanner.discover()
        assertTrue(discovered.isNotEmpty())

        // 2. Get enhanced metadata with type extraction
        val enhanced = scanner.discoverWithEnhancedMetadata(
            baseType = Repository::class.java
        )

        // 3. Build repository information
        val repoInfo = enhanced.mapNotNull { (clazz, metadata) ->
            val entityType = metadata.getTypeParameter("E")
            val dtoType = metadata.getTypeParameter("D")

            if (entityType != null && dtoType != null) {
                Triple(clazz.simpleName, entityType, dtoType)
            } else null
        }

        assertTrue(repoInfo.isNotEmpty())

        // Verify we have the expected repositories
        assertTrue(repoInfo.any { (name, _, _) -> name == "UserRepository" })
        assertTrue(repoInfo.any { (name, _, _) -> name == "ProductRepository" })
    }

    @Test
    fun `should handle large discovery sets efficiently`() {
        // Discover all test classes
        val scanner = ReflectionsTypeScanner<TestService>(
            TestService::class.java,
            listOf("com.ead.katalyst.scanner.fixtures")
        )

        val start = System.currentTimeMillis()
        val discovered = scanner.discover()
        val duration = System.currentTimeMillis() - start

        // Should complete reasonably quickly (< 5 seconds for test classes)
        assertTrue(duration < 5000)
        assertTrue(discovered.isNotEmpty())
    }

    @Test
    fun `should handle concurrent discovery operations`() {
        val scanner1 = ReflectionsTypeScanner<Repository<*, *>>(
            Repository::class.java,
            listOf("com.ead.katalyst.scanner.fixtures")
        )
        val scanner2 = ReflectionsTypeScanner<TestService>(
            TestService::class.java,
            listOf("com.ead.katalyst.scanner.fixtures")
        )

        val repos = scanner1.discover()
        val services = scanner2.discover()

        assertTrue(repos.isNotEmpty())
        assertTrue(services.isNotEmpty())
    }
}
